<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>시스템 캐싱 정책 및 데이터 흐름</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
    <style>
        :root {
            --bg-color: #1a1a1a;
            --text-color: #e0e0e0;
            --card-bg: #2d2d2d;
            --accent-color: #3b82f6;
            --border-color: #404040;
            --code-bg: #111;
        }

        body {
            font-family: 'Pretendard', -apple-system, BlinkMacSystemFont, system-ui, Roboto, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--bg-color);
            margin: 0;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background: var(--card-bg);
            padding: 40px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        h1,
        h2,
        h3 {
            color: #fff;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
            margin-top: 1.5em;
        }

        h1 {
            margin-top: 0;
            font-size: 2em;
            border-bottom: 2px solid var(--accent-color);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: var(--bg-color);
            border-radius: 8px;
            overflow: hidden;
        }

        th,
        td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        th {
            background-color: #333;
            color: var(--accent-color);
            font-weight: 600;
        }

        code {
            background-color: rgba(59, 130, 246, 0.15);
            color: #60a5fa;
            padding: 2px 6px;
            border-radius: 4px;
            font-family: 'Consolas', monospace;
            font-size: 0.9em;
        }

        pre {
            background-color: var(--code-bg);
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            border: 1px solid var(--border-color);
        }

        .mermaid {
            background-color: #fff;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            display: flex;
            justify-content: center;
        }

        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: bold;
        }

        .badge-client {
            background: #10b981;
            color: #fff;
        }

        .badge-server-mem {
            background: #f59e0b;
            color: #fff;
        }

        .badge-server-file {
            background: #6366f1;
            color: #fff;
        }

        @media (max-width: 600px) {
            .container {
                padding: 20px;
            }

            th,
            td {
                padding: 8px 10px;
                font-size: 0.9em;
            }

            h1 {
                font-size: 1.5em;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>시스템 캐싱 정책 및 데이터 흐름 분석</h1>
        <p>이 문서는 주식 모니터링 시스템의 성능 최적화와 API 비용 절감을 위해 구현된 <strong>이중 캐싱 아키텍처(Dual Caching Architecture)</strong>를 설명합니다.
        </p>

        <h2>1. 캐싱 정책 개요 (Caching Policy)</h2>
        <p>시스템은 <strong>클라이언트(브라우저)</strong>와 <strong>서버(Backend)</strong> 양쪽에서 캐싱을 수행하여 불필요한 네트워크 통신과 고비용의 AI API 호출을
            최소화합니다.</p>

        <table>
            <thead>
                <tr>
                    <th>구분</th>
                    <th>위치</th>
                    <th>저장 매체</th>
                    <th>만료 시간 (TTL)</th>
                    <th>주요 역할</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><span class="badge badge-client">클라이언트 캐시</span></td>
                    <td>사용자 브라우저</td>
                    <td>메모리 (JS 객체 <code>sentimentCache</code>)</td>
                    <td><strong>30분</strong></td>
                    <td>화면 깜빡임 방지, 서버 부하 감소, 즉각적인 UI 응답</td>
                </tr>
                <tr>
                    <td><span class="badge badge-server-mem">서버 메모리 캐시</span></td>
                    <td>Flask 서버</td>
                    <td>RAM (<code>_memory_cache</code>)</td>
                    <td><strong>10분</strong></td>
                    <td><strong>초고속 응답 (Hot Data)</strong>, 자주 조회되는 종목의 빠른 반환</td>
                </tr>
                <tr>
                    <td><span class="badge badge-server-file">서버 파일 캐시</span></td>
                    <td>서버 디스크</td>
                    <td>JSON 파일 (<code>cache/</code>)</td>
                    <td><strong>60분</strong></td>
                    <td><strong>API 비용 절감 (Long-tail)</strong>, 데이터 영속성 및 사용자 간 공유</td>
                </tr>
            </tbody>
        </table>

        <h2>2. 데이터 흐름도 (Data Flow Architecture)</h2>
        <p>사용자가 특정 종목(예: 삼성전자)의 분석 정보를 요청할 때의 데이터 처리 흐름입니다.</p>

        <div class="mermaid">
            sequenceDiagram
            participant User as 👤 사용자 (브라우저)
            participant ClientCache as 📦 클라이언트 캐시 (JS)
            participant Server as 🖥️ 서버 (Flask)
            participant ServerCache as 🗄️ 서버 캐시 (File/Mem)
            participant Gemini as 🧠 Google Gemini API

            Note over User, ClientCache: 1. 데이터 요청
            User->>ClientCache: 종목 분석 요청 (삼성전자)

            alt 클라이언트 캐시 유효 (Hit)
            ClientCache-->>User: ⚡ 즉시 반환 (0ms)
            else 클라이언트 캐시 없음 (Miss)
            ClientCache->>Server: 2. API 요청 (/api/analyze)

            Server->>ServerCache: 3. 서버 캐시 확인

            alt 서버 캐시 유효 (Hit)
            ServerCache-->>Server: 📂 파일/메모리 데이터 반환
            else 서버 캐시 없음 (Miss)
            Server->>Gemini: 4. AI 분석 요청 (💰 비용 발생)
            Gemini-->>Server: 5. 분석 결과 응답
            Server->>ServerCache: 6. 결과 저장 (공유 캐시 생성)
            end

            Server-->>ClientCache: 7. 응답 전송
            ClientCache-->>User: 8. 화면 표시 & 캐시 저장
            end
        </div>

        <h2>3. 상세 구현 로직</h2>

        <h3>A. 클라이언트 측 캐싱 (<code>static/js/main.js</code>, <code>ui.js</code>)</h3>
        <ul>
            <li><strong>저장소</strong>: <code>window.sentimentCache</code> (메모리 객체)</li>
            <li><strong>동작 원리</strong>:
                <ol>
                    <li><strong>자동 갱신 (리본/배지)</strong>: <code>updateSingleSentiment</code> 함수가 주기적으로 호출될 때, 캐시에 데이터가 있고
                        30분이 지나지 않았다면 API 호출을 건너뛰고 캐시된 데이터를 사용합니다.</li>
                    <li><strong>수동 클릭 (상세 모달)</strong>: 사용자가 카드를 클릭하면 <code>openStockModal</code> 함수가 실행됩니다.
                        <ul>
                            <li>이때 <code>loadFullAnalysis(code, false)</code>를 호출하여 <strong>강제 갱신을 하지 않고</strong> 서버 캐시를
                                우선 확인합니다.</li>
                            <li><strong>중복 요청 방지</strong>: 이미 해당 종목에 대한 분석 요청이 진행 중이라면(<code>_pendingRequests</code>),
                                새로운 요청을 보내지 않고 기존 요청이 완료될 때까지 기다립니다.</li>
                        </ul>
                    </li>
                    <li><strong>데이터 동기화</strong>: 상세 분석이 완료되면 <code>updateSentimentFromAnalysis</code>가 호출되어 최신 분석 결과를
                        <code>sentimentCache</code>에도 즉시 반영합니다. 덕분에 모달을 닫아도 리스트의 정보가 최신 상태로 유지됩니다.
                    </li>
                </ol>
            </li>
            <li><strong>효과</strong>: 사용자가 카드를 반복해서 클릭하거나 탭을 빠르게 이동해도 불필요한 네트워크 요청이 발생하지 않아 쾌적한 UX를 제공합니다.</li>
        </ul>

        <h3>B. 서버 측 캐싱 (<code>gemini_service.py</code>)</h3>
        <ul>
            <li><strong>계층적 구조</strong>: <code>메모리 캐시</code> → <code>파일 캐시</code> 순서로 확인하는 <strong>L1/L2 캐시 구조</strong>를
                가집니다.</li>
            <li><strong>파일 캐시 (L2)</strong>:
                <ul>
                    <li>경로: <code>cache/{종목코드}_{타입}_{날짜}.json</code></li>
                    <li><strong>Atomic Write</strong>: 데이터 손상을 방지하기 위해 임시 파일 작성 후 이름 변경(<code>rename</code>)
                        방식을 사용합니다.
                    </li>
                    <li><strong>공유 캐시 효과</strong>: <strong>사용자 A</strong>가 분석한 결과를 서버 파일로 저장해두면, <strong>사용자
                            B</strong>가
                        동일 종목 조회 시 API 호출 없이 저장된 파일을 그대로 반환받습니다.</li>
                </ul>
            </li>
        </ul>

        <h2>4. 서버-클라이언트 상호작용 분석 (Interaction Analysis)</h2>

        <h3>A. 서버 (Server) 동작 특성</h3>
        <ul>
            <li><strong>구글 검색의 보안성</strong>: 구글 검색 로직(<code>gemini_service.py</code>)은 100% 서버 내부에서만 실행됩니다. 클라이언트 코드는 검색
                API 키나 로직에 접근할 수 없어 보안상 안전합니다.</li>
            <li><strong>Lazy Loading (지연 로딩)</strong>: 서버는 스스로 데이터를 미리 수집하지 않습니다. 클라이언트의 <strong>요청이 들어오는 순간</strong>에만
                분석을 시작하고 결과를 캐싱합니다.</li>
        </ul>

        <h3>B. 동시 요청 처리 (Concurrency)</h3>
        <ul>
            <li><strong>시나리오</strong>: 두 명의 사용자가 거의 동시에(밀리초 차이) 같은 종목을 처음으로 조회하는 경우</li>
            <li><strong>동작</strong>: 현재 별도의 잠금(Lock) 장치가 없으므로, 두 요청 모두 API를 호출하여 중복 작업이 발생할 수 있습니다.</li>
            <li><strong>결과</strong>: 두 작업 중 나중에 끝나는 쪽의 데이터가 최종적으로 캐시 파일에 저장되며, 이후의 요청부터는 해당 캐시를 공유하게 됩니다.</li>
        </ul>

        <h2>5. 시스템 이점 (Benefits)</h2>
        <ul>
            <li><strong>비용 절감 (Cost Efficiency)</strong>: 캐싱을 통해 동일 종목에 대한 중복 호출을 90% 이상 제거할 수 있습니다.
            </li>
            <li><strong>속도 향상 (Performance)</strong>: AI 분석은 통상 3~5초가 소요되지만, 캐시된 데이터는 <strong>0.01초
                    이내</strong>에 반환됩니다.
            </li>
            <li><strong>데이터 일관성 (Consistency)</strong>: 짧은 시간 내에 여러 사용자가 조회하더라도 동일한 분석 결과를 제공하여 정보의 혼선을
                방지합니다.</li>
        </ul>
    </div>

    <script>
        mermaid.initialize({
            startOnLoad: true,
            theme: 'base',
            themeVariables: {
                primaryColor: '#e0e0e0',
                edgeLabelBackground: '#fff',
                tertiaryColor: '#fff'
            }
        });
    </script>
</body>

</html>